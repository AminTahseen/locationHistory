Index: app/src/main/java/com/masterandroid/backgroundservice/place.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.masterandroid.backgroundservice;\r\n\r\nimport com.google.gson.annotations.SerializedName;\r\n\r\npublic class place {\r\n\r\n    @SerializedName(\"placeId\")\r\n    private int placeId;\r\n\r\n    @SerializedName(\"placeLongitude\")\r\n    private double placeLongitude;\r\n\r\n    @SerializedName(\"placeLatitude\")\r\n    private double placeLatitude;\r\n\r\n    @SerializedName(\"placeAddress\")\r\n    private String placeAddress;\r\n\r\n    @SerializedName(\"city\")\r\n    private String city;\r\n\r\n    public place() { }\r\n\r\n    public place(double placeLongitude, double placeLatitude, String placeAddress, String city) {\r\n        this.placeLongitude = placeLongitude;\r\n        this.placeLatitude = placeLatitude;\r\n        this.placeAddress = placeAddress;\r\n        this.city = city;\r\n    }\r\n\r\n    public double getPlaceLatitude() {\r\n        return placeLatitude;\r\n    }\r\n\r\n    public void setPlaceLatitude(double placeLatitude) {\r\n        this.placeLatitude = placeLatitude;\r\n    }\r\n\r\n    public double getPlaceLongitude() {\r\n        return placeLongitude;\r\n    }\r\n\r\n    public void setPlaceLongitude(double placeLongitude) {\r\n        this.placeLongitude = placeLongitude;\r\n    }\r\n\r\n    public String getPlaceAddress() {\r\n        return placeAddress;\r\n    }\r\n\r\n    public void setPlaceAddress(String placeAddress) {\r\n        this.placeAddress = placeAddress;\r\n    }\r\n\r\n    public String getCity() {\r\n        return city;\r\n    }\r\n\r\n    public void setCity(String city) {\r\n        this.city = city;\r\n    }\r\n\r\n    public int getPlaceId() {\r\n        return placeId;\r\n    }\r\n\r\n    public void setPlaceId(int placeId) {\r\n        this.placeId = placeId;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/masterandroid/backgroundservice/place.java	(revision 065df1fdff9b29f6bdbc9a8c9b3fd011022ceabe)
+++ app/src/main/java/com/masterandroid/backgroundservice/place.java	(date 1607408473140)
@@ -1,29 +1,15 @@
 package com.masterandroid.backgroundservice;
 
-import com.google.gson.annotations.SerializedName;
-
 public class place {
 
-    @SerializedName("placeId")
-    private int placeId;
-
-    @SerializedName("placeLongitude")
-    private double placeLongitude;
-
-    @SerializedName("placeLatitude")
     private double placeLatitude;
-
-    @SerializedName("placeAddress")
+    private double placeLongitude;
     private String placeAddress;
-
-    @SerializedName("city")
     private String city;
 
-    public place() { }
-
-    public place(double placeLongitude, double placeLatitude, String placeAddress, String city) {
-        this.placeLongitude = placeLongitude;
+    public place(double placeLatitude, double placeLongitude, String placeAddress, String city) {
         this.placeLatitude = placeLatitude;
+        this.placeLongitude = placeLongitude;
         this.placeAddress = placeAddress;
         this.city = city;
     }
@@ -59,12 +45,4 @@
     public void setCity(String city) {
         this.city = city;
     }
-
-    public int getPlaceId() {
-        return placeId;
-    }
-
-    public void setPlaceId(int placeId) {
-        this.placeId = placeId;
-    }
 }
Index: app/src/main/java/com/masterandroid/backgroundservice/LocationService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.masterandroid.backgroundservice;\r\n\r\nimport android.Manifest;\r\nimport android.app.Service;\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.content.SharedPreferences;\r\nimport android.content.pm.PackageManager;\r\nimport android.location.Address;\r\nimport android.location.Geocoder;\r\nimport android.os.CountDownTimer;\r\nimport android.os.IBinder;\r\nimport android.os.Looper;\r\nimport android.util.Log;\r\nimport android.widget.Toast;\r\n\r\nimport androidx.annotation.Nullable;\r\nimport androidx.core.app.ActivityCompat;\r\n\r\nimport com.google.android.gms.location.LocationCallback;\r\nimport com.google.android.gms.location.LocationRequest;\r\nimport com.google.android.gms.location.LocationResult;\r\nimport com.google.android.gms.location.LocationServices;\r\nimport com.google.gson.Gson;\r\nimport com.google.gson.JsonObject;\r\nimport com.masterandroid.backgroundservice.retrofit.ApiClient;\r\nimport com.masterandroid.backgroundservice.retrofit.ApiInterface;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\n\r\nimport okhttp3.MultipartBody;\r\nimport retrofit2.Call;\r\nimport retrofit2.Callback;\r\nimport retrofit2.Response;\r\n\r\npublic class LocationService extends Service {\r\n    ApiInterface retrofit_API;\r\n\r\n    String details;\r\n    List<String> visitAddress;\r\n    static CountDownTimer countDownTimer = null;\r\n    private LocationCallback locationCallback = new LocationCallback() {\r\n        @Override\r\n        public void onLocationResult(LocationResult locationResult) {\r\n            super.onLocationResult(locationResult);\r\n            if (locationResult != null && locationResult.getLastLocation() != null) {\r\n                double longitude = locationResult.getLastLocation().getLongitude();\r\n                double latitude = locationResult.getLastLocation().getLatitude();\r\n                Log.d (\"LOCATION_UPDATE\",latitude+\",\"+longitude);\r\n                details= getAddress(longitude,latitude);\r\n                visitAddress.add(details);\r\n\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    @Nullable\r\n    @Override\r\n    public IBinder onBind(Intent intent) {\r\n        throw new UnsupportedOperationException(\"Not yet Implemented\");\r\n    }\r\n\r\n    private void startLocation()\r\n    {\r\n\r\n        if (countDownTimer != null) {\r\n            countDownTimer.cancel();\r\n        }\r\n        // 60*1*1000 = 1 min\r\n        // 50000 = 50 seconds\r\n        // 10000 = 10 seconds;\r\n\r\n        // Try Increasing countDownInterval\r\n        countDownTimer = new CountDownTimer(20000, 1000) {\r\n            public void onTick(long millisUntilFinished)\r\n            {\r\n                String left=Long.toString(millisUntilFinished);\r\n                Log.d(\"Service Time Interval \",left);\r\n\r\n                LocationRequest locationRequest = new LocationRequest();\r\n\r\n                // Try adjusting the location.setFastestInterval\r\n                /*\r\n                50*100 = 5,000 = 5 Seconds\r\n                100*100 = 10,000 = 10 Seconds\r\n                 */\r\n                locationRequest.setInterval(5000);\r\n                locationRequest.setFastestInterval(100*100);\r\n                locationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);\r\n\r\n                if (ActivityCompat.checkSelfPermission(LocationService.this, Manifest.permission.ACCESS_FINE_LOCATION)\r\n                        != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(LocationService.this,\r\n                        Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\r\n                    // TODO: Consider calling\r\n                    //    ActivityCompat#requestPermissions\r\n                    // here to request the missing permissions, and then overriding\r\n                    //   public void onRequestPermissionsResult(int requestCode, String[] permissions,\r\n                    //                                          int[] grantResults)\r\n                    // to handle the case where the user grants the permission. See the documentation\r\n                    // for ActivityCompat#requestPermissions for more details.\r\n                    return;\r\n                }\r\n                LocationServices.getFusedLocationProviderClient(LocationService.this)\r\n                        .requestLocationUpdates(locationRequest, locationCallback, Looper.getMainLooper());\r\n            }\r\n            public void onFinish()\r\n            {\r\n                Log.d(\"done!\", \"done!\");\r\n                stopLocation();\r\n                Gson gson= new Gson();\r\n                String jsonText= gson.toJson(visitAddress);\r\n                SharedPreferences sharedPreferences= getSharedPreferences(\"Details\", Context.MODE_PRIVATE);\r\n                SharedPreferences.Editor editor= sharedPreferences.edit();\r\n                editor.putString(\"AddressList\",jsonText);\r\n                editor.apply();\r\n            }\r\n        };\r\n\r\n        countDownTimer.start();\r\n        visitAddress= new ArrayList<>();\r\n\r\n    }\r\n\r\n\r\n    private void stopLocation(){\r\n        LocationServices.getFusedLocationProviderClient(this)\r\n                .removeLocationUpdates(locationCallback);\r\n        stopForeground(true);\r\n        stopSelf();\r\n        countDownTimer.cancel();\r\n\r\n    }\r\n\r\n    private String getAddress(double Longitude, double Latitude){\r\n        Geocoder geocoder;\r\n        String completeDetails=\"\";\r\n        List<Address> addresses= new ArrayList<>();\r\n        geocoder=new Geocoder(this, Locale.getDefault());\r\n\r\n        try {\r\n            addresses= geocoder.getFromLocation(Latitude,Longitude,1);\r\n            String address = addresses.get(0).getAddressLine(0); // If any additional address line present than only, check with max available address lines by getMaxAddressLineIndex()\r\n            String city = addresses.get(0).getLocality();\r\n            String state = addresses.get(0).getAdminArea();\r\n            String country = addresses.get(0).getCountryName();\r\n            String postalCode = addresses.get(0).getPostalCode();\r\n            String knownName = addresses.get(0).getFeatureName();\r\n\r\n            completeDetails= address;\r\n            Log.d(\"LOCATION Push\",\"Push In DB\");\r\n            Log.d(\"LOCATION_DETAILS\",Latitude+\", \"+Longitude+\", \"+knownName+\", \"+address);\r\n\r\n            Log.d(\"CheckForCity\",city);\r\n            place visit=new place(Longitude,Latitude,address,city);\r\n            retrofit_API= ApiClient.getClient().create(ApiInterface.class);\r\n\r\n            Call<Response> call=retrofit_API.insertUser(Double.toString(Longitude), Double.toString(Latitude), address, city);\r\n            call.enqueue(new Callback<Response>() {\r\n                @Override\r\n                public void onResponse(Call<Response> call, Response<Response> response) {\r\n                    if (!response.isSuccessful())\r\n                    {\r\n                        Log.d(\"LocationService\", \"No Success\");\r\n                    }\r\n                    else\r\n                        {\r\n                            Log.d(\"LocationService\", \"Success\");\r\n                        }\r\n                }\r\n\r\n                @Override\r\n                public void onFailure(Call<Response> call, Throwable t) {\r\n                    Log.d(\"onFailure\", t.getMessage());\r\n                }\r\n            });\r\n\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return completeDetails;\r\n    }\r\n\r\n    @Override\r\n    public int onStartCommand(Intent intent, int flags, int startId) {\r\n        if(intent!=null){\r\n            String action= intent.getAction();\r\n            if(action!=null){\r\n                if(action.equals(Constants.ACTION_START_LOCATION_SERVICE)){\r\n                    startLocation();\r\n                }\r\n                else if(action.equals(Constants.ACTION_STOP_LOCATION_SERVICE)){\r\n                    stopLocation();\r\n                }\r\n            }\r\n\r\n        }\r\n        return super.onStartCommand(intent, flags, startId);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/masterandroid/backgroundservice/LocationService.java	(revision 065df1fdff9b29f6bdbc9a8c9b3fd011022ceabe)
+++ app/src/main/java/com/masterandroid/backgroundservice/LocationService.java	(date 1607409663878)
@@ -1,6 +1,9 @@
 package com.masterandroid.backgroundservice;
 
 import android.Manifest;
+import android.app.NotificationChannel;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
 import android.app.Service;
 import android.content.Context;
 import android.content.Intent;
@@ -8,6 +11,7 @@
 import android.content.pm.PackageManager;
 import android.location.Address;
 import android.location.Geocoder;
+import android.os.Build;
 import android.os.CountDownTimer;
 import android.os.IBinder;
 import android.os.Looper;
@@ -16,6 +20,7 @@
 
 import androidx.annotation.Nullable;
 import androidx.core.app.ActivityCompat;
+import androidx.core.app.NotificationCompat;
 
 import com.google.android.gms.location.LocationCallback;
 import com.google.android.gms.location.LocationRequest;
@@ -32,8 +37,6 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
-
-import okhttp3.MultipartBody;
 import retrofit2.Call;
 import retrofit2.Callback;
 import retrofit2.Response;
@@ -43,6 +46,7 @@
 
     String details;
     List<String> visitAddress;
+
     static CountDownTimer countDownTimer = null;
     private LocationCallback locationCallback = new LocationCallback() {
         @Override
@@ -68,30 +72,48 @@
 
     private void startLocation()
     {
-
         if (countDownTimer != null) {
             countDownTimer.cancel();
         }
         // 60*1*1000 = 1 min
         // 50000 = 50 seconds
         // 10000 = 10 seconds;
-
-        // Try Increasing countDownInterval
         countDownTimer = new CountDownTimer(20000, 1000) {
             public void onTick(long millisUntilFinished)
             {
-                String left=Long.toString(millisUntilFinished);
-                Log.d("Service Time Interval ",left);
+                String channelId = "location notification channel";
+                NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
+                Intent resultIntent = new Intent();
+                PendingIntent pendingIntent = PendingIntent.getActivity(
+                        getApplicationContext(), 0,
+                        resultIntent,
+                        PendingIntent.FLAG_UPDATE_CURRENT);
+                NotificationCompat.Builder builder = new NotificationCompat.Builder(
+                        getApplicationContext(),
+                        channelId
+                );
 
+                builder.setSmallIcon(R.mipmap.ic_launcher);
+                builder.setContentTitle("Location Service");
+                builder.setDefaults(NotificationCompat.DEFAULT_ALL);
+                builder.setContentText("running");
+                builder.setContentIntent(pendingIntent);
+                builder.setAutoCancel(false);
+                builder.setPriority(NotificationCompat.PRIORITY_MAX);
+
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+                    if (notificationManager != null && notificationManager.getNotificationChannel(channelId) == null) {
+                        NotificationChannel notificationChannel = new NotificationChannel(
+                                channelId, "Location Service",
+                                NotificationManager.IMPORTANCE_HIGH
+                        );
+                        notificationChannel.setDescription("This channel is used by location service");
+                        notificationManager.createNotificationChannel(notificationChannel);
+                    }
+                }
                 LocationRequest locationRequest = new LocationRequest();
-
-                // Try adjusting the location.setFastestInterval
-                /*
-                50*100 = 5,000 = 5 Seconds
-                100*100 = 10,000 = 10 Seconds
-                 */
                 locationRequest.setInterval(5000);
-                locationRequest.setFastestInterval(100*100);
+                locationRequest.setFastestInterval(60*100);
                 locationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);
 
                 if (ActivityCompat.checkSelfPermission(LocationService.this, Manifest.permission.ACCESS_FINE_LOCATION)
@@ -108,6 +130,8 @@
                 }
                 LocationServices.getFusedLocationProviderClient(LocationService.this)
                         .requestLocationUpdates(locationRequest, locationCallback, Looper.getMainLooper());
+                startForeground(Constants.LOCATION_SERVICE_ID,builder.build());
+
             }
             public void onFinish()
             {
@@ -119,14 +143,13 @@
                 SharedPreferences.Editor editor= sharedPreferences.edit();
                 editor.putString("AddressList",jsonText);
                 editor.apply();
+
+
             }
         };
-
         countDownTimer.start();
         visitAddress= new ArrayList<>();
-
     }
-
 
     private void stopLocation(){
         LocationServices.getFusedLocationProviderClient(this)
@@ -153,7 +176,6 @@
             String knownName = addresses.get(0).getFeatureName();
 
             completeDetails= address;
-            Log.d("LOCATION Push","Push In DB");
             Log.d("LOCATION_DETAILS",Latitude+", "+Longitude+", "+knownName+", "+address);
 
             Log.d("CheckForCity",city);
@@ -166,7 +188,7 @@
                 public void onResponse(Call<Response> call, Response<Response> response) {
                     if (!response.isSuccessful())
                     {
-                        Log.d("LocationService", "No Success");
+                        Log.d("LocationService", response.message());
                     }
                     else
                         {
@@ -198,7 +220,6 @@
                     stopLocation();
                 }
             }
-
         }
         return super.onStartCommand(intent, flags, startId);
     }
Index: app/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>apply plugin: 'com.android.application'\r\napply plugin: 'com.google.gms.google-services'\r\n\r\nandroid {\r\n    compileSdkVersion 30\r\n    buildToolsVersion \"30.0.2\"\r\n    compileOptions {\r\n        sourceCompatibility JavaVersion.VERSION_1_8\r\n        targetCompatibility JavaVersion.VERSION_1_8\r\n    }\r\n\r\n    defaultConfig {\r\n        applicationId \"com.masterandroid.backgroundservice\"\r\n        minSdkVersion 19\r\n        targetSdkVersion 30\r\n        versionCode 1\r\n        versionName \"1.0\"\r\n\r\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\r\n    }\r\n\r\n    buildTypes {\r\n        release {\r\n            minifyEnabled false\r\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\r\n        }\r\n    }\r\n}\r\n\r\ndependencies {\r\n    implementation fileTree(dir: \"libs\", include: [\"*.jar\"])\r\n    implementation 'androidx.appcompat:appcompat:1.2.0'\r\n    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'\r\n    implementation 'com.google.firebase:firebase-database:16.0.4'\r\n    implementation 'com.google.android.gms:play-services-maps:16.0.0'\r\n    implementation 'com.google.android.gms:play-services-location:17.0.0'\r\n    // Import the BoM for the Firebase platform\r\n    implementation platform('com.google.firebase:firebase-bom:26.1.0')\r\n\r\n    // Declare the dependency for the Performance Monitoring library\r\n    // When using the BoM, you don't specify versions in Firebase library dependencies\r\n\r\n    implementation 'com.squareup.retrofit2:retrofit:2.9.0'\r\n    implementation 'com.squareup.retrofit2:converter-gson:2.3.0'\r\n    implementation 'com.google.code.gson:gson:2.8.6'\r\n    implementation 'com.squareup.retrofit2:converter-scalars:2.1.0'\r\n\r\n\r\n    testImplementation 'junit:junit:4.12'\r\n    androidTestImplementation 'androidx.test.ext:junit:1.1.2'\r\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/build.gradle	(revision 065df1fdff9b29f6bdbc9a8c9b3fd011022ceabe)
+++ app/build.gradle	(date 1607408498286)
@@ -44,8 +44,6 @@
     implementation 'com.squareup.retrofit2:converter-gson:2.3.0'
     implementation 'com.google.code.gson:gson:2.8.6'
     implementation 'com.squareup.retrofit2:converter-scalars:2.1.0'
-
-
     testImplementation 'junit:junit:4.12'
     androidTestImplementation 'androidx.test.ext:junit:1.1.2'
     androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'
Index: app/src/main/java/com/masterandroid/backgroundservice/mainService.java
===================================================================
--- app/src/main/java/com/masterandroid/backgroundservice/mainService.java	(revision 065df1fdff9b29f6bdbc9a8c9b3fd011022ceabe)
+++ app/src/main/java/com/masterandroid/backgroundservice/mainService.java	(revision 065df1fdff9b29f6bdbc9a8c9b3fd011022ceabe)
@@ -1,63 +0,0 @@
-package com.masterandroid.backgroundservice;
-
-import android.app.Service;
-import android.content.Intent;
-import android.os.IBinder;
-import android.util.Log;
-
-import androidx.annotation.Nullable;
-
-import com.google.firebase.database.DataSnapshot;
-import com.google.firebase.database.DatabaseError;
-import com.google.firebase.database.DatabaseReference;
-import com.google.firebase.database.FirebaseDatabase;
-import com.google.firebase.database.ValueEventListener;
-
-public class mainService extends Service {
-    private final String TAG="service";
-    // Write a message to the database
-    FirebaseDatabase database = FirebaseDatabase.getInstance();
-    DatabaseReference myRef = database.getReference("Places_Api_Data");
-
-    @Override
-    public int onStartCommand(Intent intent, int flags, int startId) {
-        Log.d(TAG,"Service has started");
-       // myRef.setValue("Hello, World!");
-
-        // Read from the database
-        myRef.addValueEventListener(new ValueEventListener() {
-            @Override
-            public void onDataChange(DataSnapshot dataSnapshot) {
-                if(dataSnapshot.exists())
-                {
-                    for (DataSnapshot child:dataSnapshot.getChildren())
-                    {
-                        place obj=child.getValue(place.class);
-                        //obj.setKey(child.getKey());
-                        Log.d(TAG, "Value from service is: " + obj.toString());
-
-                    }
-                }
-            }
-
-            @Override
-            public void onCancelled(DatabaseError error) {
-                // Failed to read value
-                Log.w(TAG, "Failed to read Value from service ", error.toException());
-            }
-        });
-
-        return START_STICKY;
-    }
-
-    @Override
-    public void onDestroy() {
-        super.onDestroy();
-    }
-
-    @Nullable
-    @Override
-    public IBinder onBind(Intent intent) {
-        return null;
-    }
-}
Index: app/src/main/java/com/masterandroid/backgroundservice/MyLocationService.java
===================================================================
--- app/src/main/java/com/masterandroid/backgroundservice/MyLocationService.java	(revision 065df1fdff9b29f6bdbc9a8c9b3fd011022ceabe)
+++ app/src/main/java/com/masterandroid/backgroundservice/MyLocationService.java	(revision 065df1fdff9b29f6bdbc9a8c9b3fd011022ceabe)
@@ -1,179 +0,0 @@
-package com.masterandroid.backgroundservice;
-import android.Manifest;
-import android.app.Service;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.location.Location;
-import android.location.LocationListener;
-import android.location.LocationManager;
-import android.nfc.Tag;
-import android.os.Bundle;
-import android.os.IBinder;
-import android.util.Log;
-import android.widget.Toast;
-import androidx.core.app.ActivityCompat;
-import androidx.core.app.NotificationCompat;
-import androidx.core.app.NotificationManagerCompat;
-
-import com.masterandroid.backgroundservice.retrofit.ApiClient;
-import com.masterandroid.backgroundservice.retrofit.ApiInterface;
-
-
-/**
- * Created by roberto on 9/29/16.
- */
-
-public class MyLocationService extends Service {
-    public static final String BROADCAST_ACTION = "Hello World";
-    private static final int TWO_MINUTES = 1000 * 60 * 2;
-    public LocationManager locationManager;
-    public MyLocationListener listener;
-    public Location previousBestLocation = null;
-    String TAG="Location Service";
-    Intent intent;
-    int counter = 0;
-
-
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        intent = new Intent(BROADCAST_ACTION);
-    }
-    @Override
-    public void onStart(Intent intent, int startId) {
-        locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
-        listener = new MyLocationListener();
-        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
-            return;
-        }
-        locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 4000, 0, (LocationListener) listener);
-        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 4000, 0, listener);
-    }
-
-    @Override
-    public IBinder onBind(Intent intent) {
-        return null;
-    }
-
-    protected boolean isBetterLocation(Location location, Location currentBestLocation) {
-        if (currentBestLocation == null) {
-            // A new location is always better than no location
-            return true;
-        }
-        // Check whether the new location fix is newer or older
-        long timeDelta = location.getTime() - currentBestLocation.getTime();
-        boolean isSignificantlyNewer = timeDelta > TWO_MINUTES;
-        boolean isSignificantlyOlder = timeDelta < -TWO_MINUTES;
-        boolean isNewer = timeDelta > 0;
-
-        // If it's been more than two minutes since the current location, use the new location
-        // because the user has likely moved
-        if (isSignificantlyNewer) {
-            return true;
-            // If the new location is more than two minutes older, it must be worse
-        } else if (isSignificantlyOlder) {
-            return false;
-        }
-        // Check whether the new location fix is more or less accurate
-        int accuracyDelta = (int) (location.getAccuracy() - currentBestLocation.getAccuracy());
-        boolean isLessAccurate = accuracyDelta > 0;
-        boolean isMoreAccurate = accuracyDelta < 0;
-        boolean isSignificantlyLessAccurate = accuracyDelta > 200;
-
-        // Check if the old and new location are from the same provider
-        boolean isFromSameProvider = isSameProvider(location.getProvider(),
-                currentBestLocation.getProvider());
-
-        // Determine location quality using a combination of timeliness and accuracy
-        if (isMoreAccurate) {
-            return true;
-        } else if (isNewer && !isLessAccurate) {
-            return true;
-        } else if (isNewer && !isSignificantlyLessAccurate && isFromSameProvider) {
-            return true;
-        }
-        return false;
-    }
-    /**
-     * Checks whether two providers are the same
-     */
-    private boolean isSameProvider(String provider1, String provider2) {
-        if (provider1 == null) {
-            return provider2 == null;
-        }
-        return provider1.equals(provider2);
-    }
-    @Override
-    public void onDestroy() {
-       // handler.removeCallbacks(sendUpdatesToUI);
-        super.onDestroy();
-        Log.d("STOP_SERVICE", "DONE");
-        locationManager.removeUpdates(listener);
-    }
-
-    public static Thread performOnBackgroundThread(final Runnable runnable) {
-        final Thread t = new Thread() {
-            @Override
-            public void run() {
-                try {
-                    runnable.run();
-                } finally {
-
-                }
-            }
-        };
-        t.start();
-        return t;
-    }
-
-    public class MyLocationListener implements LocationListener {
-
-        public void onLocationChanged(final Location loc) {
-            Log.i("*****", "Location changed");
-            if (isBetterLocation(loc, previousBestLocation)) {
-                loc.getLatitude();
-                loc.getLongitude();
-                intent.putExtra("Latitude", loc.getLatitude());
-                intent.putExtra("Longitude", loc.getLongitude());
-                intent.putExtra("Provider", loc.getProvider());
-
-                //
-
-               // sendNotification("Location Changed",loc.toString());
-                sendBroadcast(intent);
-                Log.d(TAG,loc.getLatitude()+" "+loc.getLongitude());
-
-            }
-        }
-
-        @Override
-        public void onStatusChanged(String provider, int status, Bundle extras) {
-
-        }
-
-        public void onProviderDisabled(String provider) {
-          //  Toast.makeText(getApplicationContext(), "Gps Disabled", Toast.LENGTH_SHORT).show();
-        }
-
-
-        public void onProviderEnabled(String provider) {
-            Toast.makeText(getApplicationContext(), "Gps Enabled", Toast.LENGTH_SHORT).show();
-        }
-    }
-
-    private void sendNotification(String title,String content){
-        NotificationCompat.Builder builder = new NotificationCompat.Builder(this)
-                .setSmallIcon(R.mipmap.ic_launcher)
-                .setContentTitle(title)
-                .setContentText(content)
-                .setPriority(NotificationCompat.PRIORITY_DEFAULT);
-        NotificationManagerCompat notificationManager = NotificationManagerCompat.from(this);
-
-        // notificationId is a unique int for each notification that you must define
-        notificationManager.notify(1, builder.build());
-    }
-
-
-}
\ No newline at end of file
Index: app/src/main/java/com/masterandroid/backgroundservice/Api.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/masterandroid/backgroundservice/Api.java	(date 1607408473150)
+++ app/src/main/java/com/masterandroid/backgroundservice/Api.java	(date 1607408473150)
@@ -0,0 +1,4 @@
+package com.masterandroid.backgroundservice;
+
+public class Api {
+}
