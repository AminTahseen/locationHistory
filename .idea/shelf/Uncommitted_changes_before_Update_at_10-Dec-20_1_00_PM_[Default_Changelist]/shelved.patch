Index: app/src/main/java/com/masterandroid/backgroundservice/LocationService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.masterandroid.backgroundservice;\r\n\r\nimport android.Manifest;\r\nimport android.app.Service;\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.content.SharedPreferences;\r\nimport android.content.pm.PackageManager;\r\nimport android.location.Address;\r\nimport android.location.Geocoder;\r\nimport android.os.AsyncTask;\r\nimport android.os.CountDownTimer;\r\nimport android.os.IBinder;\r\nimport android.os.Looper;\r\nimport android.util.Log;\r\nimport android.widget.Toast;\r\n\r\nimport androidx.annotation.Nullable;\r\nimport androidx.core.app.ActivityCompat;\r\n\r\nimport com.google.android.gms.location.LocationCallback;\r\nimport com.google.android.gms.location.LocationRequest;\r\nimport com.google.android.gms.location.LocationResult;\r\nimport com.google.android.gms.location.LocationServices;\r\n\r\nimport com.masterandroid.backgroundservice.retrofit.ApiClient;\r\nimport com.masterandroid.backgroundservice.retrofit.ApiInterface;\r\n\r\nimport org.json.JSONArray;\r\nimport org.json.JSONException;\r\nimport org.json.JSONObject;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\nimport java.util.jar.JarEntry;\r\n\r\nimport okhttp3.MultipartBody;\r\nimport retrofit2.Call;\r\nimport retrofit2.Callback;\r\nimport retrofit2.Response;\r\n\r\npublic class LocationService extends Service {\r\n    ApiInterface retrofit_API;\r\n    private static final int CODE_GET_REQUEST = 1024;\r\n    private static final int CODE_POST_REQUEST = 1025;\r\n    place details;\r\n    List<place> visitAddress;\r\n    static CountDownTimer countDownTimer = null;\r\n\r\n    private LocationCallback locationCallback = new LocationCallback() {\r\n        @Override\r\n        public void onLocationResult(LocationResult locationResult) {\r\n            super.onLocationResult(locationResult);\r\n            if (locationResult != null && locationResult.getLastLocation() != null) {\r\n                double longitude =  locationResult.getLastLocation().getLongitude();\r\n                double latitude = locationResult.getLastLocation().getLatitude();\r\n                Log.d (\"LOCATION_UPDATE\",latitude+\",\"+longitude);\r\n                details= getAddress(longitude,latitude);\r\n               // getDetailsFromAPI(latitude+\",\"+longitude,\"AIzaSyDazjxsJFdohTwZllHdMsacB4P9luVjqyE\");\r\n                getPlaceSearchDetails(details.getPlaceAddress(),\r\n                        \"textquery\",\r\n                        \"photos,formatted_address,name,opening_hours,rating,types\",\r\n                        \"circle:2000@\"+latitude+\",\"+longitude,\r\n                        \"AIzaSyDazjxsJFdohTwZllHdMsacB4P9luVjqyE\");\r\n\r\n                HashMap<String, String> params = new HashMap<>();\r\n                params.put(\"placeLatitude\",String.valueOf(details.getPlaceLatitude()));\r\n                params.put(\"placeLongitude\",String.valueOf(details.getPlaceLongitude()));\r\n                params.put(\"placeAddress\",details.getPlaceAddress());\r\n                params.put(\"city\",details.getCity());\r\n\r\n                PerformNetworkRequest request = new PerformNetworkRequest(Api.URL_CREATE_LIST, params, CODE_POST_REQUEST);\r\n                request.execute();\r\n                // visitAddress.add(details);\r\n            }\r\n        }\r\n    };\r\n\r\n    @Nullable\r\n    @Override\r\n    public IBinder onBind(Intent intent) {\r\n        throw new UnsupportedOperationException(\"Not yet Implemented\");\r\n    }\r\n\r\n    private void startLocation()\r\n    {\r\n        if (countDownTimer != null) {\r\n           countDownTimer.cancel();\r\n        }\r\n        // 60*1*1000 = 1 min\r\n        // 50000 = 50 seconds\r\n        // 10000 = 10 seconds;\r\n\r\n        // Try Increasing countDownInterval\r\n        countDownTimer = new CountDownTimer(60000, 1000) {\r\n            public void onTick(long millisUntilFinished)\r\n            {\r\n                String left=Long.toString(millisUntilFinished);\r\n                Log.d(\"Service Time Interval \",left);\r\n\r\n                LocationRequest locationRequest = new LocationRequest();\r\n\r\n                // Try adjusting the location.setFastestInterval\r\n                /*\r\n                50*100 = 5,000 = 5 Seconds\r\n                100*100 = 10,000 = 10 Seconds\r\n                 */\r\n                locationRequest.setInterval(5000);\r\n                locationRequest.setFastestInterval(100*400);\r\n                locationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);\r\n\r\n                if (ActivityCompat.checkSelfPermission(LocationService.this, Manifest.permission.ACCESS_FINE_LOCATION)\r\n                        != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(LocationService.this,\r\n                        Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\r\n                    // TODO: Consider calling\r\n                    //    ActivityCompat#requestPermissions\r\n                    // here to request the missing permissions, and then overriding\r\n                    //   public void onRequestPermissionsResult(int requestCode, String[] permissions,\r\n                    //                                          int[] grantResults)\r\n                    // to handle the case where the user grants the permission. See the documentation\r\n                    // for ActivityCompat#requestPermissions for more details.\r\n                    return;\r\n                }\r\n                LocationServices.getFusedLocationProviderClient(LocationService.this)\r\n                        .requestLocationUpdates(locationRequest, locationCallback, Looper.getMainLooper());\r\n            }\r\n            public void onFinish()\r\n            {\r\n                Log.d(\"done!\", \"done!\");\r\n                stopLocation();\r\n            }\r\n        };\r\n        countDownTimer.start();\r\n    }\r\n\r\n\r\n    private void stopLocation(){\r\n        LocationServices.getFusedLocationProviderClient(this)\r\n                .removeLocationUpdates(locationCallback);\r\n        stopForeground(true);\r\n        stopSelf();\r\n     //   countDownTimer.cancel();\r\n\r\n    }\r\n\r\n    public void getDetailsFromAPI(String location, final String api_key){\r\n        final ApiInterface apiInterface= ApiClient.getClient().create(ApiInterface.class);\r\n        Call<ResponseModel> call= apiInterface.getDetails(location,1,api_key);\r\n        call.enqueue(new Callback<ResponseModel>() {\r\n            @Override\r\n            public void onResponse(Call<ResponseModel> call, Response<ResponseModel> response) {\r\n                if(response.isSuccessful()){\r\n                    try{\r\n\r\n                    }\r\n                    catch (Exception e){\r\n\r\n                    }\r\n\r\n                }\r\n                else{\r\n                    Log.d(\"Response: \" , response.message());\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void onFailure(Call<ResponseModel> call, Throwable t) {\r\n                Log.d(\"Response: \" , t.getMessage());\r\n            }\r\n        });\r\n    }\r\n\r\n    public void getPlaceSearchDetails(String input, String inputtime, String fields,String location,String key){\r\n        final ApiInterface apiInterface= ApiClient.getClient().create(ApiInterface.class);\r\n        Call <ResponseModel> call=apiInterface.getPlaceSearch(input,inputtime,fields,location,key);\r\n        call.enqueue(new Callback<ResponseModel>() {\r\n            @Override\r\n            public void onResponse(Call<ResponseModel> call, Response<ResponseModel> response) {\r\n                if(response.isSuccessful()){\r\n\r\n                }\r\n                else{\r\n\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void onFailure(Call<ResponseModel> call, Throwable t) {\r\n                Log.d(\"Response: \" , t.getMessage());\r\n            }\r\n        });\r\n    }\r\n\r\n    private place getAddress(double Longitude, double Latitude){\r\n        Geocoder geocoder;\r\n        place completeDetails=null;\r\n        List<Address> addresses= new ArrayList<>();\r\n        geocoder=new Geocoder(this, Locale.getDefault());\r\n\r\n        try {\r\n            addresses= geocoder.getFromLocation(Latitude,Longitude,1);\r\n            String address = addresses.get(0).getAddressLine(0); // If any additional address line present than only, check with max available address lines by getMaxAddressLineIndex()\r\n            String city = addresses.get(0).getLocality();\r\n            String state = addresses.get(0).getAdminArea();\r\n            String country = addresses.get(0).getCountryName();\r\n            String postalCode = addresses.get(0).getPostalCode();\r\n            String knownName = addresses.get(0).getFeatureName();\r\n\r\n            completeDetails= new place(Latitude,Longitude,address,city);\r\n            Log.d(\"LOCATION Push\",\"Push In DB\");\r\n            Log.d(\"LOCATION_DETAILS\",Latitude+\", \"+Longitude+\", \"+knownName+\", \"+address);\r\n\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return completeDetails;\r\n    }\r\n\r\n    @Override\r\n    public int onStartCommand(Intent intent, int flags, int startId) {\r\n        if(intent!=null){\r\n            String action= intent.getAction();\r\n            if(action!=null){\r\n                if(action.equals(Constants.ACTION_START_LOCATION_SERVICE)){\r\n                    startLocation();\r\n                }\r\n                else if(action.equals(Constants.ACTION_STOP_LOCATION_SERVICE)){\r\n                    stopLocation();\r\n                }\r\n            }\r\n        }\r\n        return super.onStartCommand(intent, flags, startId);\r\n    }\r\n\r\n    private class PerformNetworkRequest extends AsyncTask<Void, Void, String> {\r\n\r\n        //the url where we need to send the request\r\n        String url;\r\n\r\n        //the parameters\r\n        HashMap<String, String> params;\r\n\r\n        //the request code to define whether it is a GET or POST\r\n        int requestCode;\r\n\r\n        //constructor to initialize values\r\n        PerformNetworkRequest(String url, HashMap<String, String> params, int requestCode) {\r\n            this.url = url;\r\n            this.params = params;\r\n            this.requestCode = requestCode;\r\n        }\r\n\r\n        //when the task started displaying a progressbar\r\n        @Override\r\n        protected void onPreExecute() {\r\n            super.onPreExecute();\r\n        }\r\n\r\n\r\n        //this method will give the response from the request\r\n        @Override\r\n        protected void onPostExecute(String s) {\r\n            super.onPostExecute(s);\r\n            try {\r\n                JSONObject object = new JSONObject(s);\r\n                if (!object.getBoolean(\"error\")) {\r\n                    Toast.makeText(getApplicationContext(), object.getString(\"message\"), Toast.LENGTH_SHORT).show();\r\n                    //refreshing the herolist after every operation\r\n                    //so we get an updated list\r\n                    //we will create this method right now it is commented\r\n                    //because we haven't created it yet\r\n                    //refreshList(object.getJSONArray(\"myLists\"));\r\n                }\r\n            } catch (JSONException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        //the network operation will be performed in background\r\n        @Override\r\n        protected String doInBackground(Void... voids) {\r\n            RequestHandler requestHandler = new RequestHandler();\r\n\r\n            if (requestCode == CODE_POST_REQUEST)\r\n                return requestHandler.sendPostRequest(url, params);\r\n\r\n            if (requestCode == CODE_GET_REQUEST)\r\n                return requestHandler.sendGetRequest(url);\r\n\r\n            return null;\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/masterandroid/backgroundservice/LocationService.java	(revision 88f27fbec0c71ba5138e3b88f7ab6df8bf0d16d6)
+++ app/src/main/java/com/masterandroid/backgroundservice/LocationService.java	(date 1607587231590)
@@ -49,7 +49,6 @@
     private static final int CODE_GET_REQUEST = 1024;
     private static final int CODE_POST_REQUEST = 1025;
     place details;
-    List<place> visitAddress;
     static CountDownTimer countDownTimer = null;
 
     private LocationCallback locationCallback = new LocationCallback() {
@@ -61,6 +60,7 @@
                 double latitude = locationResult.getLastLocation().getLatitude();
                 Log.d ("LOCATION_UPDATE",latitude+","+longitude);
                 details= getAddress(longitude,latitude);
+
                // getDetailsFromAPI(latitude+","+longitude,"AIzaSyDazjxsJFdohTwZllHdMsacB4P9luVjqyE");
                 getPlaceSearchDetails(details.getPlaceAddress(),
                         "textquery",
@@ -87,6 +87,10 @@
         throw new UnsupportedOperationException("Not yet Implemented");
     }
 
+    public void passDataInDatabase(place Details){
+
+    }
+
     private void startLocation()
     {
         if (countDownTimer != null) {
@@ -176,6 +180,7 @@
     }
 
     public void getPlaceSearchDetails(String input, String inputtime, String fields,String location,String key){
+
         final ApiInterface apiInterface= ApiClient.getClient().create(ApiInterface.class);
         Call <ResponseModel> call=apiInterface.getPlaceSearch(input,inputtime,fields,location,key);
         call.enqueue(new Callback<ResponseModel>() {
