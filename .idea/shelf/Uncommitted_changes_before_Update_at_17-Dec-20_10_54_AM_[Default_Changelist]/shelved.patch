Index: app/src/main/java/com/masterandroid/backgroundservice/LocationService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.masterandroid.backgroundservice;\r\n\r\nimport android.Manifest;\r\nimport android.app.Service;\r\nimport android.content.Intent;\r\nimport android.content.pm.PackageManager;\r\nimport android.location.Address;\r\nimport android.location.Geocoder;\r\nimport android.os.AsyncTask;\r\nimport android.os.CountDownTimer;\r\nimport android.os.IBinder;\r\nimport android.os.Looper;\r\nimport android.util.Log;\r\nimport android.widget.Toast;\r\nimport androidx.annotation.Nullable;\r\nimport androidx.core.app.ActivityCompat;\r\nimport com.google.android.gms.location.LocationCallback;\r\nimport com.google.android.gms.location.LocationRequest;\r\nimport com.google.android.gms.location.LocationResult;\r\nimport com.google.android.gms.location.LocationServices;\r\nimport com.google.firebase.auth.FirebaseAuth;\r\nimport com.google.firebase.auth.FirebaseUser;\r\nimport com.masterandroid.backgroundservice.retrofit.ApiClient;\r\nimport com.masterandroid.backgroundservice.retrofit.ApiInterface;\r\nimport org.json.JSONException;\r\nimport org.json.JSONObject;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\nimport retrofit2.Call;\r\nimport retrofit2.Callback;\r\nimport retrofit2.Response;\r\n\r\npublic class LocationService extends Service {\r\n    private static final int CODE_GET_REQUEST = 1024;\r\n    private static final int CODE_POST_REQUEST = 1025;\r\n    FirebaseUser currentUser;\r\n\r\n    place details;\r\n    static CountDownTimer countDownTimer = null;\r\n    List<place> place_detailsArrayList;\r\n    private LocationCallback locationCallback = new LocationCallback() {\r\n        @Override\r\n        public void onLocationResult(LocationResult locationResult) {\r\n            super.onLocationResult(locationResult);\r\n            if (locationResult != null && locationResult.getLastLocation() != null) {\r\n                double longitude =  locationResult.getLastLocation().getLongitude();\r\n                double latitude = locationResult.getLastLocation().getLatitude();\r\n                Log.d (\"LOCATION_UPDATE\",latitude+\",\"+longitude);\r\n                details= getGeocodingDetails(longitude,latitude);\r\n               // getDetailsFromAPI(latitude+\",\"+longitude,\"AIzaSyDazjxsJFdohTwZllHdMsacB4P9luVjqyE\");\r\n                storeDataInDatabase(details,latitude,longitude);\r\n            }\r\n        }\r\n    };\r\n\r\n    @Nullable\r\n    @Override\r\n    public IBinder onBind(Intent intent) {\r\n        throw new UnsupportedOperationException(\"Not yet Implemented\");\r\n    }\r\n\r\n    private void startLocation()\r\n    {\r\n        if (countDownTimer != null) {\r\n           countDownTimer.cancel();\r\n        }\r\n        // 60*30*1000 = 30 min\r\n        // 60*10*1000 = 10 min\r\n        // 50000 = 50 seconds\r\n        // 10000 = 10 seconds\r\n        // 60000 = 60 seconds\r\n\r\n        // Try Increasing countDownInterval\r\n        countDownTimer = new CountDownTimer( 20000, 1000) {\r\n            public void onTick(long millisUntilFinished)\r\n            {\r\n                String left=Long.toString(millisUntilFinished);\r\n                Log.d(\"Service Time Interval \",left);\r\n\r\n                LocationRequest locationRequest = new LocationRequest();\r\n\r\n                // Try adjusting the location.setFastestInterval\r\n                /*\r\n                50*100 = 5,000 = 5 Seconds\r\n                100*100 = 10,000 = 10 Seconds\r\n                100*400 = 40,000 = 40 Seconds\r\n                100*600 = 60,000 = 60 Seconds\r\n                100*900 = 90,000 = 90 Seconds\r\n\r\n                 */\r\n                locationRequest.setInterval(5000);\r\n                locationRequest.setFastestInterval(100*100);\r\n                locationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);\r\n\r\n                if (ActivityCompat.checkSelfPermission(LocationService.this, Manifest.permission.ACCESS_FINE_LOCATION)\r\n                        != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(LocationService.this,\r\n                        Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\r\n                    // TODO: Consider calling\r\n                    //    ActivityCompat#requestPermissions\r\n                    // here to request the missing permissions, and then overriding\r\n                    //   public void onRequestPermissionsResult(int requestCode, String[] permissions,\r\n                    //                                          int[] grantResults)\r\n                    // to handle the case where the user grants the permission. See the documentation\r\n                    // for ActivityCompat#requestPermissions for more details.\r\n                    return;\r\n                }\r\n                LocationServices.getFusedLocationProviderClient(LocationService.this)\r\n                        .requestLocationUpdates(locationRequest, locationCallback, Looper.getMainLooper());\r\n            }\r\n            public void onFinish()\r\n            {\r\n                Log.d(\"done!\", \"done!\");\r\n                stopLocation();\r\n            }\r\n        };\r\n        countDownTimer.start();\r\n    }\r\n\r\n\r\n    public void stopLocation(){\r\n        LocationServices.getFusedLocationProviderClient(this)\r\n                .removeLocationUpdates(locationCallback);\r\n        stopForeground(true);\r\n        stopSelf();\r\n      countDownTimer.cancel();\r\n\r\n    }\r\n\r\n    public void storeDataInDatabase(place obj, double lat, double lng)\r\n    {\r\n        getPlaceSearchDetails(lat,lng,obj.getPlaceAddress(),\r\n                \"textquery\",\r\n                \"photos,formatted_address,name,opening_hours,rating,types\",\r\n                \"circle:2000@\"+lat+\",\"+lng,\r\n                \"AIzaSyDazjxsJFdohTwZllHdMsacB4P9luVjqyE\");\r\n\r\n\r\n    }\r\n    public void storeData(String UserId, String name, String address,String type,double latitude, double longitude, String VisitStatus)\r\n    {\r\n\r\n        HashMap<String, String> params = new HashMap<>();\r\n\r\n        params.put(\"userId\",UserId);\r\n        params.put(\"placeLatitude\",String.valueOf(latitude));\r\n        params.put(\"placeLongitude\",String.valueOf(longitude));\r\n        params.put(\"placeAddress\",address);\r\n        params.put(\"placeName\",name);\r\n        params.put(\"placeType\",type);\r\n        params.put(\"visitStatus\",VisitStatus);\r\n\r\n        PerformNetworkRequest request = new PerformNetworkRequest(Api.URL_CREATE_LIST, params, CODE_POST_REQUEST);\r\n        request.execute();\r\n\r\n    }\r\n\r\n    public void getPlaceSearchDetails(double latitude, double longitude, String input, String inputtime, String fields,String location,String key){\r\n        place_detailsArrayList=new ArrayList<>();\r\n        final ApiInterface apiInterface= ApiClient.getClient().create(ApiInterface.class);\r\n        Call <ResponseModel> call=apiInterface.getPlaceSearch(input,inputtime,fields,location,key);\r\n        call.enqueue(new Callback<ResponseModel>() {\r\n            @Override\r\n            public void onResponse(Call<ResponseModel> call, Response<ResponseModel> response) {\r\n                if(response.isSuccessful())\r\n                {\r\n                    //place myPlace= new place();\r\n                    place_detailsArrayList=response.body().getCandidates();\r\n                    for(int i=0;i<place_detailsArrayList.size();i++)\r\n                    {\r\n                        String name=place_detailsArrayList.get(i).getPlaceName();\r\n                        String address=place_detailsArrayList.get(i).getPlaceAddress();\r\n                       // Log.d(\"API Success\",place_detailsArrayList.get(i).getPlaceName());\r\n                        String type= place_detailsArrayList.get(i).getPlaceType().toString();\r\n                        Log.d(\"Full Details \",name+' '+address+' '+type);\r\n                       // FirebaseAuth mAuth=FirebaseAuth.getInstance();\r\n                     //   currentUser = mAuth.getCurrentUser();\r\n\r\n                        storeData(\"GuzFS0EjtBSwuRXBuRfhFN8ZSfm1\",name,address,type,latitude,longitude,\"pending\");\r\n\r\n                    }\r\n                }\r\n                else{\r\n\r\n                }\r\n            }\r\n            @Override\r\n            public void onFailure(Call<ResponseModel> call, Throwable t) {\r\n                Log.d(\"onFailure Response: \" , t.getMessage());\r\n            }\r\n        });\r\n    }\r\n\r\n    private place getGeocodingDetails(double Longitude, double Latitude){\r\n        Geocoder geocoder;\r\n        place completeDetails=null;\r\n        List<Address> addresses= new ArrayList<>();\r\n        geocoder=new Geocoder(this, Locale.getDefault());\r\n\r\n        try {\r\n            addresses= geocoder.getFromLocation(Latitude,Longitude,1);\r\n            String address = addresses.get(0).getAddressLine(0); // If any additional address line present than only, check with max available address lines by getMaxAddressLineIndex()\r\n            String city = addresses.get(0).getLocality();\r\n            String state = addresses.get(0).getAdminArea();\r\n            String country = addresses.get(0).getCountryName();\r\n            String postalCode = addresses.get(0).getPostalCode();\r\n            String knownName = addresses.get(0).getFeatureName();\r\n\r\n            completeDetails= new place(\"GuzFS0EjtBSwuRXBuRfhFN8ZSfm1\",Latitude,Longitude,address,\"pending\");\r\n            Log.d(\"LOCATION_DETAILS\",Latitude+\", \"+Longitude+\", \"+knownName+\", \"+address);\r\n\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return completeDetails;\r\n    }\r\n\r\n    @Override\r\n    public int onStartCommand(Intent intent, int flags, int startId) {\r\n        if(intent!=null){\r\n            String action= intent.getAction();\r\n            if(action!=null){\r\n                if(action.equals(Constants.ACTION_START_LOCATION_SERVICE)){\r\n                    startLocation();\r\n\r\n                }\r\n                else if(action.equals(Constants.ACTION_STOP_LOCATION_SERVICE)){\r\n                    stopLocation();\r\n                }\r\n            }\r\n        }\r\n        return super.onStartCommand(intent, flags, startId);\r\n    }\r\n\r\n    private class PerformNetworkRequest extends AsyncTask<Void, Void, String> {\r\n\r\n        //the url where we need to send the request\r\n        String url;\r\n        // comment\r\n        //the parameters\r\n        HashMap<String, String> params;\r\n\r\n        //the request code to define whether it is a GET or POST\r\n        int requestCode;\r\n\r\n        //constructor to initialize values\r\n        PerformNetworkRequest(String url, HashMap<String, String> params, int requestCode) {\r\n            this.url = url;\r\n            this.params = params;\r\n            this.requestCode = requestCode;\r\n        }\r\n\r\n        //when the task started displaying a progressbar\r\n        @Override\r\n        protected void onPreExecute() {\r\n            super.onPreExecute();\r\n        }\r\n\r\n\r\n        //this method will give the response from the request\r\n        @Override\r\n        protected void onPostExecute(String s) {\r\n            super.onPostExecute(s);\r\n            try {\r\n                JSONObject object = new JSONObject(s);\r\n                if (!object.getBoolean(\"error\")) {\r\n                    Toast.makeText(getApplicationContext(), object.getString(\"message\"), Toast.LENGTH_SHORT).show();\r\n                    //refreshing the herolist after every operation\r\n                    //so we get an updated list\r\n                    //we will create this method right now it is commented\r\n                    //because we haven't created it yet\r\n                    //refreshList(object.getJSONArray(\"myLists\"));\r\n                }\r\n            } catch (JSONException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n        //the network operation will be performed in background\r\n        @Override\r\n        protected String doInBackground(Void... voids) {\r\n            RequestHandler requestHandler = new RequestHandler();\r\n\r\n            if (requestCode == CODE_POST_REQUEST)\r\n                return requestHandler.sendPostRequest(url, params);\r\n\r\n            if (requestCode == CODE_GET_REQUEST)\r\n                return requestHandler.sendGetRequest(url);\r\n\r\n            return null;\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/masterandroid/backgroundservice/LocationService.java	(revision 4bdfaa0d1dcbeaa7594e625f090b8e52ad7c9006)
+++ app/src/main/java/com/masterandroid/backgroundservice/LocationService.java	(date 1608118140462)
@@ -74,7 +74,7 @@
         // 60000 = 60 seconds
 
         // Try Increasing countDownInterval
-        countDownTimer = new CountDownTimer( 20000, 1000) {
+        countDownTimer = new CountDownTimer( 60*10*1000, 1000) {
             public void onTick(long millisUntilFinished)
             {
                 String left=Long.toString(millisUntilFinished);
@@ -92,7 +92,7 @@
 
                  */
                 locationRequest.setInterval(5000);
-                locationRequest.setFastestInterval(100*100);
+                locationRequest.setFastestInterval(100*400);
                 locationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);
 
                 if (ActivityCompat.checkSelfPermission(LocationService.this, Manifest.permission.ACCESS_FINE_LOCATION)
